package com.liyangbin.cartrofit.processor;

import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;
import com.squareup.javapoet.WildcardTypeName;

import java.io.IOException;
import java.io.Writer;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.AnnotationMirror;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.PackageElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeKind;
import javax.lang.model.type.TypeMirror;
import javax.tools.Diagnostic;

import static javax.lang.model.element.Modifier.FINAL;
import static javax.lang.model.element.Modifier.PRIVATE;
import static javax.lang.model.element.Modifier.PUBLIC;
import static javax.lang.model.element.Modifier.STATIC;

@SupportedAnnotationTypes({CartrofitProcessor.PROCESS})
@SupportedSourceVersion(SourceVersion.RELEASE_8)
public class CartrofitProcessor extends AbstractProcessor {
    private static final String PACKAGE_NAME = "com.liyangbin.cartrofit";
    static final String PROCESS = PACKAGE_NAME + ".annotation.Process";
    static final String CALLBACK = PACKAGE_NAME + ".annotation.Callback";
    private static final String ROUTER_NAME = "IdRouter";
    private static final String INVOKE_HELPER_NAME = "CallbackInvoker";
    private static final String COMMENT_COMMON = "This class is generated by CartrofitProcessor."
            + " Do not modify this file directly.\n" + new Date().toString();
    private static final String METHOD_WARNING = "This method is accessed from Cartrofit framework," +
            " do not call this method from app code";

    private final HashMap<Integer, ClassName> mScopeMap = new HashMap<>();

    @Override
    public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {
        Set<? extends Element> elements = roundEnvironment.getRootElements();
        if (elements.size() == 0) {
            return false;
        }
        for (Element element : elements) {
            processElement(element);
        }
        processIdMapperClass();
        return true;
    }

    private void processElement(Element element) {
        final ElementKind kind = element.getKind();
        if (kind == ElementKind.INTERFACE) {
            List<? extends AnnotationMirror> list = element.getAnnotationMirrors();
            for (AnnotationMirror annotationMirror : list) {
                DeclaredType annotationElement = annotationMirror.getAnnotationType();
                String annotationName = annotationElement.toString();
                if (PROCESS.equals(annotationName)) {
                    if (element.getModifiers().contains(PUBLIC)) {
                        logI("process interface api element:" + element);
                        processApiClass((TypeElement) element);
                    } else {
                        logE("Can only declare api with public Modifier " + element);
                    }
                    break;
                }
            }
        } else if (kind == ElementKind.CLASS) {
            List<? extends Element> enclosedElements = element.getEnclosedElements();
            logI("process class api element:" + element);
            for (Element enclosedElement : enclosedElements) {
                processElement(enclosedElement);
            }
        }
    }

    private boolean checkClassExist(String className) {
        return processingEnv.getElementUtils().getTypeElement(className) != null;
    }

    private void processIdMapperClass() {
        if (mScopeMap.size() == 0) {
            return;
        }
        String routerFullName;
        int count = 0;
        do {
            count++;
            routerFullName = PACKAGE_NAME + "." + ROUTER_NAME + count;
            if (checkClassExist(routerFullName)) {
                logI("router:" + routerFullName + " existed, loop to find next");
            } else {
                break;
            }
        } while (true);
        logI("generate router:" + routerFullName);

        TypeSpec.Builder routerBuilder = TypeSpec.classBuilder(ROUTER_NAME + count)
                .addModifiers(PUBLIC, FINAL);
        routerBuilder.addField(FieldSpec
                .builder(TypeName.INT, "SCOPE_MASK")
                .addModifiers(PRIVATE, STATIC, FINAL)
                .initializer("0x" + Integer.toHexString(SCOPE_MASK))
                .build());
        routerBuilder.addMethod(MethodSpec.constructorBuilder().addModifiers(PRIVATE).build());

        MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder("findApiClassById")
                .addModifiers(STATIC, PUBLIC)
                .returns(ParameterizedTypeName.get(ClassName.get(Class.class),
                        WildcardTypeName.subtypeOf(Object.class)))
                .addParameter(TypeName.INT, "id");
        methodBuilder.beginControlFlow("switch(id & SCOPE_MASK)");
        for (Map.Entry<Integer, ClassName> entry : mScopeMap.entrySet()) {
            methodBuilder
                    .addCode("case $L: ", entry.getKey())
                    .addStatement("return $T.class", entry.getValue());
        }
        methodBuilder.endControlFlow();
        methodBuilder.addStatement("return null");

        routerBuilder.addMethod(methodBuilder.build());

        try (Writer writer = processingEnv.getFiler()
                .createSourceFile(routerFullName)
                .openWriter()) {
            JavaFile.builder(PACKAGE_NAME, routerBuilder.build())
                    .addFileComment(COMMENT_COMMON)
                    .skipJavaLangImports(true)
                    .indent("    ")
                    .build()
                    .writeTo(writer);
        } catch (IOException e) {
            e.printStackTrace();
        }
        mScopeMap.clear();
    }

    private void processApiClass(TypeElement element) {
        Element parentElement = element.getEnclosingElement();
        PackageElement packageElement = null;
        ArrayList<String> prefixChain = null;
        while (packageElement == null) {
            ElementKind kind = parentElement.getKind();
            if (kind == ElementKind.PACKAGE) {
                packageElement = (PackageElement) parentElement;
            } else {
                if (parentElement.getKind() == ElementKind.CLASS) {
                    if (!parentElement.getModifiers().contains(PUBLIC)) {
                        logE("Can only declare api int public context " + parentElement);
                        return;
                    }
                    if (prefixChain == null) {
                        prefixChain = new ArrayList<>();
                    }
                    prefixChain.add(parentElement.getSimpleName().toString());
                    parentElement = parentElement.getEnclosingElement();
                } else {
                    logE("Can only declare api as independent interface class " +
                            "or inside other class " + element);
                    return;
                }
            }
        }
        StringBuilder classNameBuffer = new StringBuilder();
        if (prefixChain != null) {
            for (int i = prefixChain.size() - 1; i >= 0; i--) {
                classNameBuffer.append(prefixChain.get(i)).append("_");
            }
        }
        classNameBuffer.append(element.getSimpleName().toString());
        final String packageName = packageElement.getQualifiedName().toString();
        String apiClassName = classNameBuffer.toString();
        ClassName idClassName = ClassName.get(packageName, apiClassName + "Id");
        TypeSpec.Builder indexClassBuilder = TypeSpec.classBuilder(idClassName)
                .addModifiers(PUBLIC, FINAL);

        ArrayList<ExecutableElement> apiInterface = new ArrayList<>();
        resolveExecutableElement(element, apiInterface);

        if (apiInterface.size() == 0) {
            logW("Empty CarApi interface found:" + apiClassName);
            return;
        }

        final int baseScopeId = getScopeBaseId(element.getQualifiedName().toString());
        if (mScopeMap.put(baseScopeId, ClassName.get(element)) != null) {
            logE("conflict scopeId: 0x" + Integer.toHexString(baseScopeId)
                    + " from:" + apiClassName);
            return;
        }

        ArrayList<TypeElement> callbackTypeElements = new ArrayList<>();
        HashMap<String, String> apiIndexMap = new HashMap<>();
        for (int i = 0; i < apiInterface.size(); i++) {
            ExecutableElement childElement = apiInterface.get(i);
            String name = childElement.getSimpleName().toString();
            int index = baseScopeId + i;
            apiIndexMap.put(name, idClassName.simpleName() + "." + name);
            indexClassBuilder.addField(FieldSpec
                    .builder(TypeName.INT, name, STATIC, FINAL, PUBLIC)
                    .addJavadoc("{@link $T#" + name + "}", ClassName.get(element))
                    .initializer("" + index)
                    .build());

            // collect @Callback type
            List<? extends VariableElement> parameterElements = childElement.getParameters();
            for (int j = 0; j < parameterElements.size(); j++) {
                VariableElement variableElement = parameterElements.get(j);
                List<? extends AnnotationMirror> parameterAnnotationList =
                        variableElement.getAnnotationMirrors();
                for (int k = 0; k < parameterAnnotationList.size(); k++) {
                    DeclaredType annotationElement = parameterAnnotationList.get(k).getAnnotationType();
                    String annotationName = annotationElement.toString();
                    if (CALLBACK.equals(annotationName)) {
                        TypeMirror parameterTypeMirror = variableElement.asType();
                        if (parameterTypeMirror.getKind() == TypeKind.DECLARED) {
                            TypeElement parameterType = (TypeElement) ((DeclaredType) parameterTypeMirror).asElement();
                            if (!callbackTypeElements.contains(parameterType)) {
                                callbackTypeElements.add(parameterType);
                            }
                        }
                        break;
                    }
                }
            }
        }

        final ClassName invokerIf = ClassName.get(PACKAGE_NAME, INVOKE_HELPER_NAME);
        final ClassName hashMap = ClassName.get(HashMap.class);

        MethodSpec.Builder importBuilder = MethodSpec.methodBuilder("_init")
                .addModifiers(STATIC, PUBLIC)
                .addJavadoc(METHOD_WARNING)
                .addParameter(
                        // HashMap<Integer, Method> apiMap
                        ParameterizedTypeName.get(hashMap,
                        ClassName.get(Integer.class),
                        ClassName.get(Method.class)), "apiMap")
                .addParameter(
                        // HashMap<Class<?>, HashMap<String, CallbackInvokeHelper>> callbackOutput
                        ParameterizedTypeName.get(hashMap,
                                ParameterizedTypeName.get(ClassName.get(Class.class),
                                        WildcardTypeName.subtypeOf(Object.class)),
                        ParameterizedTypeName.get(hashMap,
                                ClassName.get(String.class), invokerIf)),
                        "callbackMap");

        importBuilder.addStatement("final $T[] methods = $T.class.getDeclaredMethods()",
                ClassName.get(Method.class), ClassName.get(element))
                .beginControlFlow("for (Method method : methods)")
                .addStatement("String methodName = method.getName()");

        boolean firstTime = true;
        for (Map.Entry<String, String> entry : apiIndexMap.entrySet()) {
            String judgement = "if (methodName.equals($S))";
            String name = entry.getKey();
            if (firstTime) {
                importBuilder.beginControlFlow(judgement, name);
            } else {
                importBuilder.nextControlFlow("else " + judgement, name);
            }
            firstTime = false;
            importBuilder.addStatement("apiMap.put($L, method)", entry.getValue());
        }
        if (!firstTime) {
            importBuilder.endControlFlow();
        }
        importBuilder.endControlFlow();

        if (callbackTypeElements.size() > 0) {
            for (int i = 0; i < callbackTypeElements.size(); i++) {
                TypeElement callbackType = callbackTypeElements.get(i);
                ClassName callbackTypeName = ClassName.get(callbackType);
                ArrayList<ExecutableElement> callbackElementList = new ArrayList<>();
                resolveExecutableElement(callbackType, callbackElementList);
                if (callbackElementList.size() == 0) {
                    logE("invalid callback type " + callbackType);
                    break;
                }

                final String mapName = "_" + callbackType.getSimpleName() + "Map";
                importBuilder.addStatement("$T<$T, $T> " + mapName + " = new $T<>()",
                        hashMap, ClassName.get(String.class), invokerIf, hashMap);
                importBuilder.addStatement("callbackMap.put($T.class, $L)", callbackTypeName, mapName);

                for (int j = 0; j < callbackElementList.size(); j++) {
                    ExecutableElement callback = callbackElementList.get(j);

                    MethodSpec.Builder invokerBuilder = MethodSpec.methodBuilder("invoke")
                            .addAnnotation(Override.class)
                            .addModifiers(PUBLIC)
                            .returns(TypeName.OBJECT)
                            .addParameter(TypeName.OBJECT, "target")
                            .addParameter(Object[].class, "parameter");
                    invokerBuilder.addStatement("$T callback = ($T) target", callbackTypeName, callbackTypeName);

                    StringBuilder castAndCall;
                    boolean returnNullInTheEnd;
                    if (callback.getReturnType().getKind() == TypeKind.VOID) {
                        castAndCall = new StringBuilder("callback.$L(");
                        returnNullInTheEnd = true;
                    } else {
                        castAndCall = new StringBuilder("return callback.$L(");
                        returnNullInTheEnd = false;
                    }

                    List<? extends VariableElement> callbackParameters = callback.getParameters();
                    final int parameterCount = callbackParameters.size();
                    Object[] trigger = new Object[parameterCount + 1];
                    trigger[0] = callback.getSimpleName();
                    for (int k = 0; k < parameterCount; k++) {
                        castAndCall.append("($T)parameter[").append(k).append("]");
                        if (k < parameterCount - 1) {
                            castAndCall.append(", ");
                        }
                        trigger[k + 1] = ClassName.get(callbackParameters.get(k).asType());
                    }
                    castAndCall.append(")");
                    invokerBuilder.addStatement(castAndCall.toString(), trigger);
                    if (returnNullInTheEnd) {
                        invokerBuilder.addStatement("return null");
                    }

                    importBuilder.addStatement("$L.put($S, $L)",
                            mapName,
                            callback.getSimpleName(),
                            TypeSpec.anonymousClassBuilder("")
                                    .addSuperinterface(invokerIf)
                                    .addMethod(invokerBuilder.build())
                                    .build());
                }
            }
        }

        indexClassBuilder.addMethod(importBuilder.build());

        try (Writer writer = processingEnv.getFiler()
                .createSourceFile(idClassName.reflectionName())
                .openWriter()) {
            JavaFile.builder(packageName, indexClassBuilder.build())
                    .addFileComment(COMMENT_COMMON)
                    .skipJavaLangImports(true)
                    .indent("    ")
                    .build()
                    .writeTo(writer);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private static final int SCOPE_SHIFT_BIT = 8;
    private static final int SCOPE_MASK = 0xFFFFFFFF << SCOPE_SHIFT_BIT;

    private static int getScopeBaseId(String input) {
        return input.hashCode() << SCOPE_SHIFT_BIT;
    }

    private void logI(String msg) {
        processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, msg);
    }

    private void logW(String msg) {
        processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING, msg);
    }

    private void logE(String msg) {
        processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, msg);
    }

    private void resolveExecutableElement(TypeElement element, ArrayList<ExecutableElement> elements) {
        List<? extends Element> enclosedElements = element.getEnclosedElements();
        for (int i = 0; i < enclosedElements.size(); i++) {
            Element elementMember = enclosedElements.get(i);
            ElementKind kind = elementMember.getKind();
            if (kind == ElementKind.METHOD) {
                elements.add((ExecutableElement) elementMember);
            }
        }
    }

//    private void processSuperClass(TypeElement element) {
//        // parse ProcessSuper annotation
//        List<? extends AnnotationMirror> list = element.getAnnotationMirrors();
//        String userExplicitName = null;
//        ClassName userExplicitSuperClass = null;
//        ArrayList<ClassName> constructorParameterList = null;
//        ArrayList<TypeElement> targetInterfaceList = new ArrayList<>();
//        for (int i = 0; i < list.size(); i++) {
//            AnnotationMirror annotation = list.get(i);
//            TypeElement annotatedElement = (TypeElement) annotation.getAnnotationType().asElement();
//            if (PROCESS_SUPER.equals(annotatedElement.getQualifiedName().toString())) {
//                for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry
//                        : annotation.getElementValues().entrySet()) {
//                    ExecutableElement method = entry.getKey();
//                    AnnotationValue value = entry.getValue();
//                    String methodName = method.getSimpleName().toString();
//                    if (IMPLEMENT_CLASS_NAME.equals(methodName)) {
//                        List<AnnotationValue> valueList = (List<AnnotationValue>) value.getValue();
//                        for (int j = 0; j < valueList.size(); j++) {
//                            DeclaredType type = (DeclaredType) valueList.get(j).getValue();
//                            targetInterfaceList.add((TypeElement) type.asElement());
//                        }
//                    } else if (CLASS_NAME.equals(methodName)) {
//                        userExplicitName = (String) value.getValue();
//                    } else if (SUPER_NAME.equals(methodName)) {
//                        DeclaredType type = (DeclaredType) value.getValue();
//                        TypeElement typeElement = (TypeElement) type.asElement();
//                        if (!Object.class.getName().equals(typeElement.getQualifiedName().toString())) {
//                            userExplicitSuperClass = ClassName.get(typeElement);
//                        }
//                    } else if (SUPER_CONSTRUCTOR.equals(methodName)) {
//                        List<AnnotationValue> valueList = (List<AnnotationValue>) value.getValue();
//                        for (int j = 0; j < valueList.size(); j++) {
//                            DeclaredType type = (DeclaredType) valueList.get(j).getValue();
//                            if (constructorParameterList == null) {
//                                constructorParameterList = new ArrayList<>();
//                            }
//                            constructorParameterList.add(ClassName.get((TypeElement) type.asElement()));
//                        }
//                    }
//                }
//            }
//        }
//        if (targetInterfaceList.size() == 0) {
//            logE("Annotation must supply a valid interface name");
//            return;
//        }
//
//        // resolve class name(including super class name), and build impl class
//        PackageElement packageElement = (PackageElement) element.getEnclosingElement();
//        String packageName = packageElement.getQualifiedName().toString();
//        ClassName implClassName = ClassName.get(packageName, userExplicitName != null
//                ? userExplicitName : (targetInterfaceList.get(0).getSimpleName().toString() + "Impl"));
//        TypeSpec.Builder implClassBuilder = TypeSpec.classBuilder(implClassName)
//                .addModifiers(PUBLIC, ABSTRACT);
//        ArrayList<TypeName> targetInterfaceType = new ArrayList<>();
//        for (int i = 0; i < targetInterfaceList.size(); i++) {
//            targetInterfaceType.add(ClassName.get(targetInterfaceList.get(i)));
//        }
//        implClassBuilder.addSuperinterfaces(targetInterfaceType);
//        logI("generate class packageName:" + packageName + " className:" + implClassName);
//
//        // declare constructor if user specified
//        if (userExplicitSuperClass != null) {
//            implClassBuilder.superclass(userExplicitSuperClass);
//            if (constructorParameterList != null && constructorParameterList.size() > 0) {
//                MethodSpec.Builder constructorBuilder = MethodSpec.constructorBuilder();
//                StringBuilder superCall = new StringBuilder("super(");
//                final int parameterCount = constructorParameterList.size();
//                for (int i = 0; i < parameterCount; i++) {
//                    ClassName parameterType = constructorParameterList.get(i);
//                    String variableName = parameterType.simpleName().toLowerCase();
//                    constructorBuilder.addParameter(parameterType, variableName);
//                    superCall.append(variableName);
//                    if (i < parameterCount - 1) {
//                        superCall.append(", ");
//                    }
//                }
//                superCall.append(")");
//                constructorBuilder.addStatement(superCall.toString());
//                implClassBuilder.addMethod(constructorBuilder.addModifiers(PUBLIC).build());
//            }
//        }
//
//        int interfaceCount = targetInterfaceType.size();
//        for (int i = 0; i < interfaceCount; i++) {
//            // declare base field
//            TypeName name = targetInterfaceType.get(i);
//            String fieldName = interfaceCount == 1 ? "mBase" : ("mBase" + i);
//            implClassBuilder.addField(name, fieldName, Modifier.PRIVATE);
//
//            // declare getBase() method
//            String methodName = interfaceCount == 1 ? "getBase" : ("getBase" + i);
//            implClassBuilder.addMethod(MethodSpec.methodBuilder(methodName)
//                    .returns(name)
//                    .addModifiers(PRIVATE, Modifier.FINAL)
//                    .beginControlFlow("if ($L == null)", fieldName)
//                    .addStatement(fieldName + " = $T.from($T.class)",
//                            CAR_RETROFIT_NAME, name)
//                    .endControlFlow()
//                    .addStatement("return $L", fieldName)
//                    .build());
//        }
//
//        // resolve method which need to be implemented
//        for (int i = 0; i < targetInterfaceList.size(); i++) {
//            TypeElement targetInterface = targetInterfaceList.get(i);
//            ArrayList<ExecutableElement> executableElements = new ArrayList<>();
//            resolveExecutableElement(targetInterface, executableElements);
//            List<? extends TypeMirror> interfaceList = targetInterface.getInterfaces();
//            for (int j = 0; j < interfaceList.size(); j++) {
//                DeclaredType mirror = (DeclaredType) interfaceList.get(j);
//                resolveExecutableElement((TypeElement) mirror.asElement(), executableElements);
//            }
//
//            // declare these methods
//            for (int j = 0; j < executableElements.size(); j++) {
//                ExecutableElement executable = executableElements.get(j);
//                MethodSpec.Builder methodBuilder = MethodSpec.overriding(executable);
//                String methodName = interfaceCount == 1 ? "getBase" : ("getBase" + i);
//                StringBuilder buffer = new StringBuilder(methodName + "()."
//                        + executable.getSimpleName().toString() + "(");
//                final int parameterCount = executable.getParameters().size();
//                for (int k = 0; k < parameterCount; k++) {
//                    VariableElement variableElement = executable.getParameters().get(k);
//                    buffer.append(variableElement.getSimpleName());
//                    if (k < parameterCount - 1) {
//                        buffer.append(", ");
//                    }
//                }
//                buffer.append(")");
//                if (executable.getReturnType().getKind() == TypeKind.VOID) {
//                    methodBuilder.addStatement(buffer.toString());
//                } else {
//                    methodBuilder.addStatement("return " + buffer.toString());
//                }
//                implClassBuilder.addMethod(methodBuilder.build());
//            }
//        }
//
//        // done, write to target path
//        try (Writer writer = processingEnv.getFiler()
//                .createSourceFile(implClassName.reflectionName())
//                .openWriter()) {
//            JavaFile.builder(packageName, implClassBuilder.build())
//                    .addFileComment(COMMENT_COMMON)
//                    .skipJavaLangImports(true)
//                    .indent("    ")
//                    .build()
//                    .writeTo(writer);
//        } catch (IOException e) {
//            e.printStackTrace();
//        }
//    }
}